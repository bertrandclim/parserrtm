######## PARSERRTM MODULE VERSION 1 #########
#                                           #
#  Version one features:                    #
#    -- read input into self                #
#    -- write input to file                 #
#    -- autogen bash run script             #
#    -- run rrtm without leaving python     #
#    -- read output flux/hr to xarray       #
#                                           #
#                                           #
#          October 13, 2023                 #
#                                           #
#############################################

import numpy as np
import pandas as pd
import xarray as xr

import warnings
from pathlib import Path
import os,stat              # for chmod'ing output scripts and type-checking
import copy                 # for writing to file
from collections import abc # for type-checking
import contextlib           # for Runner to use multiple log files
import subprocess           # for Runner to execute rrtm from Python
import re                   # for Runner cleanup matching folder names

from fortranformat import FortranRecordReader, FortranRecordWriter, config


config.RET_UNWRITTEN_VARS_NONE = False #zero-fill instead of NA-fill missing values

def fpaths_union(fpaths_a, fpaths_b, verbose=True):
    fna, fnb = [p.name for p in fpaths_a], [p.name for p in fpaths_b]
    fnab = set(fna).intersection(fnb)
    fpaths_a_thin = filter(lambda p: p.name in fnab, fpaths_a)
    fpaths_b_thin = filter(lambda p: p.name in fnab, fpaths_b)
    if verbose:
        a_but_not_b = set(fna).difference(fnb)
        b_but_not_a = set(fnb).difference(fna)
        if a_but_not_b:
            print(f'removed {a_but_not_b} from fpaths_a')
        if b_but_not_a:
            print(f'remove {b_but_not_a} from fpaths_b')
    return list(fpaths_a_thin), list(fpaths_b_thin)

def read_output(fpath):
    '''
    Read RRTM_LW ASCII output file and parse to xarray.Dataset.
    Adapted from https://github.com/climatedyn/RRTM_LW.
    Arguments:
        Absolute path to RRTM_LW output file
    Returns:
        Xarray.Dataset with contents of file
    '''
    
    #loop over file to get number of numeric lines to read
    with open(fpath,'r') as f:
        #load lines as list
        lnes = f.readlines()
        #find the line # of a form-feed+newline (this marks the end of the table)
        indx = lnes.index('\x0c\n')
        #get lines before column names and after table to save as metadata
        global_attrs = {'source': fpath,
                        'created_by':'parserrtm',
                        'output_header': lnes[0],
                        'output_footer': lnes[indx+1:]}

    #parse with pandas
    ds = pd.read_fwf(
                        fpath,
                        header=[1,2], #2nd and 3rd lines (1st gets auto-skipped)
                        nrows=indx-3, #remove three leading text lines
                        widths=[8,13,14,14,14,19], #field widths
                        index_col=0 #use LEVEL for index
                    ).to_xarray()

    #put units in attrs, format varnames
    ds = ds.rename({'index':'level'})
    rname = { }
    for var in ds.data_vars:
        if var[0].replace(' ','_').lower() == 'netflux': 
            rname[var] = 'net_flux'
        else:
            rname[var] = var[0].replace(' ','_').lower()
        ds[var].attrs['units'] = var[1]
    ds = ds.rename(rname)
    #store non-table data in global attrs
    ds.attrs = global_attrs
    return ds

def write_batch_run_script(inputs, script_name='batch_rrtm_runs.sh', basepath = '.',
                           path_to_executable='/Users/will/linuxvm/rrtm_lw_pgf90/rrtm_v3.3_linux_pgf90'):
    '''
    Write shell script to execute a series of RRTM_LW runs.
    
    Inputs should be a list of either pyparserrtm.Input objects or 
    a list of input filenames. Since cloudy runs require two input 
    files, the list should be tuples corresponding to (input_rrtm, 
    in_cld_rrtm) file names.
    '''
    
    p    = Path(basepath)
    q    = Path(path_to_executable)
    q, x = q.parent, q.name
    
    with (p / script_name).open('w') as f:
        f.write('#!/bin/bash\n')
        f.write('# script auto-generated by parserrtm\n')
        f.write(f'cd {q}\n')
        for filein in inputs:
            
            #NOTE NOTE NOTE: a
            if type(filein) == list:
                f.write(f'echo RUN {filein[0]} {filein[1]}\n')
                f.write(f'cp {(p / filein[0]).resolve()} INPUT_RRTM\n')
                f.write(f'cp {(p / filein[1]).resolve()} IN_CLD_RRTM\n')
                f.write(f'./{x}; echo EXIT $?\n')
                f.write(f"mv OUTPUT_RRTM {(p / ('output_rrtm'+filein[1][11:])).resolve()} \n") #quick fix
                f.write(f"mv OUT_CLD_RRTM {(p / ('out_cld_rrtm'+filein[1][11:])).resolve()} \n")
                f.write('\n')
            
            else:
                f.write(f'echo RUN {filein}\n')
                f.write(f'cp {(p / filein).resolve()} INPUT_RRTM\n')
                f.write(f'./{x}; echo EXIT $?\n')
                f.write(f"mv OUTPUT_RRTM {(p / ('output_rrtm'+filein[10:])).resolve()} \n")
                f.write('\n')

        f.write('rm INPUT_RRTM IN_CLD_RRTM TAPE6 TAPE7')

    #chmod u+x on script
    st = os.stat(p / script_name)
    os.chmod(p / script_name, st.st_mode | stat.S_IEXEC)

### INPUT CLASS ###
def read_input(*args):
    if len(args) == 1:
        return Input(args[0])
    else:
        return Input(args)

class Input:
    
    def __repr__(self):
        recs = { }
        for rec in ['1.1','1.2','1.4']:
            for field in self.get_fields(rec):
                val = getattr(self,field)
                recs[field] = val
        return str(recs)
        
    def __str__(self):
        recs = { }
        for rec in ['1.1','1.2','1.4']:
            for field in self.get_fields(rec):
                val = getattr(self,field)
                recs[field] = val
        return str(recs)

    def __init__(self, args):
        
        #treat as a filename if argument is filepath-like
        if isinstance(args, (str, os.PathLike)):
            fpath = args
            self.read_input_rrtm(fpath)
            self.fpath_input_rrtm = fpath
        
        #treat as a dictionary of fields if argument is dict-like
        elif isinstance(args, abc.Mapping):
            self.from_dict(args,file='both',lazy=False)
        
        #treat as a pair of filenames if argument is list-like
        elif isinstance(args, abc.Sequence) and (len(args)==2):
            fpath = args
            self.read_input_rrtm(fpath[0])
            self.read_in_cld_rrtm(fpath[1])
            self.fpath_input_rrtm = fpath[0]
            self.fpath_in_cld_rrtm = fpath[1]
        
        else:
            raise TypeError('Expected one of {} or {} of length 2, got {} instead'.format(
                (abc.Mapping,str,os.PathLike),abc.Sequence, type(fpath)))
        
    def __getitem__(self, item):
         return getattr(self,item)

    def __setitem__(self, item, val):
        setattr(self,item, val)
        
    def from_dict(self,args,file='both',lazy=False):
        '''Apply a dictionary to a parserrtm.Input object.
        
        Dictionary keys are treated as field names. Optionally
        initialize needed fields for valid file(s).
        
        Parameters
        ---------
        self : parserrtm.Input
            Input object to which to apply dictionary
        args : dict-like
            dictionary containing field:value pairs to apply
        file : str, optional
            key indicating which file types for which to fill in missing fields.
            Options are 'both', 'input_rrtm', and 'in_cld_rrtm'. Default is 'both'.
            Only used if lazy is False.
        lazy : bool, optional
            Skip checking and filling in any needed fields for a valid input file 
            that are missing in args. Default is False (i.e. filling-in is the default).
    
        Returns
        --------
        self : parserrtm.Input
            Input object with fields initialized according to arguments
        '''
        #1. put all supplied fields into self
        for name,value in args.items():
            setattr(self,name,value)
    
        #2. initialize any missing fields with default values, if lazy==False
        if not lazy:
            # initialize fields needed to write different files based on "file" argument
            if file in ('both','input_rrtm'):
                #1. fill in fields needed for logical record order,
                #   if not already supplied. NB: this list is excessive
                required = ['IATM','ICLD','NMOL','IXSECT','IXMOLS','IBMAX','MODEL','IXSECT','IPRFL']
                for name in required:
                    if not hasattr(self,name):
                        default = 7 if name == 'NMOL' else 0
                        setattr(self,name,default)
            
                #2. get all needed fields via logical record order
                records = self.get_logical_record_order('input_rrtm')
                for record in records:
                    names = self.get_fields(record)
                    for name in names:
                        if not hasattr(self,name):
                            if 'CHAR' in name:
                                default = " "
                            else:
                                default = 0
                            setattr(self,name,default)
                            
            if file in ('both','in_cld_rrtm'):
                
                #1. fill in fields needed for logical record order,
                #   if not already supplied. 
                required = ['INFLAG']
                for name in required:
                    if not hasattr(self,name):
                        default = 0
                        setattr(self,name,default)
            
                #2. get all needed fields via logical record order
                records = self.get_logical_record_order('in_cld_rrtm')
                for record in records:
                    names = self.get_fields(record)
                    for name in names:
                        if not hasattr(self,name):
                            if 'CHAR' in name:
                                default = " "
                            else:
                                default = 0
                            setattr(self,name,default)
            return self

    def broadcast_scalars(self,file='both'):
        '''
        Broadcast any scalar fields in repeated (listed) records to proper lengths
        '''
        if file == 'both':
            files = ('input_rrtm','in_cld_rrtm')
        else:
            files = [file]
        for file in files:
            records = self.get_logical_record_order(file)
            for record in records:
                if Input.islist(record):
                    length = self.record_len(record)
                    names  = self.get_fields(record)
                    for name in names:
                        val = getattr(self,name)
                        if not isinstance(val,list):
                            setattr(self,name,[val]*length)
        return self
        
    def print(self):
        self.fancy_print('input_rrtm')
        if self.ICLD>0:
            self.fancy_print('in_cld_rrtm')
        
    def fancy_print(self, file='input_rrtm'):
        '''
        Print out all fields record-by-record to the console
        '''
        
        records = self.get_logical_record_order(file)
        for rec in records:
            print('-----------------------------')
            print(f'{rec}: \n',end='')
            fields = self.get_fields(rec)
            d      = {key:getattr(self,key) for key in fields}
            if not Input.islist(rec):
                print(d)
            else:
                #dict of lists to DataFrame
                df = pd.DataFrame(d)
                with pd.option_context('display.max_rows', 10, 
                                       'display.max_columns', 10, 
                                       'display.float_format','{:,.2E}'.format):
                    print(df)
                    #                     if len(df) < 10:
#                         print(df.to_string())
#                     else:
#                         #do a little fancy printing -- manually print head and tail,
#                         #so very long tables don't take up too much space
#                         print(df.head().to_string())
#                         print('...')
#                         print('\n'.join(df.tail().to_string().split('\n')[1:]))
        print('-----------------------------')
                
            
    def islist(rec):
        '''
        return if record is a list (True) or scalar (False)
        '''
        lists = ['2.1.1','2.1.2','2.1.3','2.2.3','2.2.4','2.2.5','3.5','3.6.1','3.8.1','3.8.2','C1.2','C1.3','C1.3a']
        return rec in lists

    def record_len(self,rec):
        '''
        Return number of times a record is repeated.
        '''
        lens = {
            '2.1.1': lambda self: self.NLAYRS,
            '2.1.2': lambda self: self.NLAYRS,
            '2.1.3': lambda self: self.NLAYRS,
            '2.2.3': lambda self: self.NLAYRS,
            '2.2.4': lambda self: self.NLAYRS,
            '2.2.5': lambda self: self.NLAYRS,
            '3.5':   lambda self: self.IMMAX,
            '3.6.1': lambda self: self.IMMAX,
            '3.8.1': lambda self: self.LAYX,
            '3.8.2': lambda self: self.LAYX,
            'C1.2':  lambda self: 1 if type(self.LAY) != list else len(self.LAY),
            'C1.3':  lambda self: 1 if type(self.LAY) != list else len(self.LAY),
            'C1.3a': lambda self: 15
        }
        return lens[rec](self)
            
    def get_logical_record_order(self,file='input_rrtm'):
        '''
        Get record order to print out. Logical order means
        no repeated records.
        
        Options: file = 'input_rrtm', 'in_cld_rrtm'
        '''
        
        #go through logic
        if file == 'input_rrtm':
            records = ['1.1','1.2','1.4']
            if self.IATM == 0:
                records.append('2.1')
                records.append('2.1.1')
                records.append('2.1.2')
                if self.NMOL > 7:
                    records.append('2.1.3')
                if self.IXSECT == 1:
                    records.append('2.2')
                    records.append('2.2.1')
                    records.append('2.2.2')
                    records.append('2.2.3') #dummy
                    records.append('2.2.4')
                    if self.IXMOLS > 7:
                        records.append('2.2.5')
            elif self.IATM == 1:
                records.append('3.1')
                records.append('3.2')
                if self.IBMAX == 0:
                    records.append('3.3A')
                else:
                    records.append('3.3B') #GREEDY
                if self.MODEL == 0:
                    records.append('3.4')
                    records.append('3.5')
                    records.append('3.6.1')
                if self.IXSECT == 1:
                    records.append('3.7')
                    records.append('3.7.1')
                    if self.IPRFL == 0: 
                        records.append('3.8')
                        records.append('3.8.1')
                        records.append('3.8.2')

        elif file == 'in_cld_rrtm':
            #iterate/read over records
            records = ['C1.1']
            if (self.INFLAG == 1) or (self.INFLAG == 2):
                    records.append('C1.2')
            elif (self.INFLAG == 0) or (self.INFLAG == 10):
                for i in range(len(self.LAY)): #number of cloudy layers
                    records.append('C1.3')
                    if self.INFLAG == 10:
                        raise NotImplementedError('INFLAG=10 (spectrally-resolved COD) not yet supported!')
                        for i in range(15):
                            records.append('C1.3a')
        
        return records
            
        
        
    def get_explicit_record_order(self,file='input_rrtm'):
        '''Get line-by-line records to print out.
        
        Options: file = 'input_rrtm', 'in_cld_rrtm'
        '''
        #go through logic
        if file == 'input_rrtm':
            records = ['1.1','1.2','1.4']
            if self.IATM == 0:
                records.append('2.1')
                for i in range(self.NLAYRS):
                    records.append('2.1.1')
                    records.append('2.1.2')
                    if self.NMOL > 7:
                        records.append('2.1.3')
                if self.IXSECT == 1:
                    records.append('2.2')
                    records.append('2.2.1')
                    records.append('2.2.2')
                    for i in range(self.NLAYRS):
                        records.append('2.2.3') #dummy
                        records.append('2.2.4')
                        if self.IXMOLS > 7:
                            records.append('2.2.5')
            elif self.IATM == 1:
                records.append('3.1')
                records.append('3.2')
                if self.IBMAX == 0:
                    records.append('3.3A')
                else:
                    records.append('3.3B') #GREEDY
                if self.MODEL == 0:
                    records.append('3.4')
                    for i in range(self.IMMAX):
                        records.append('3.5')
                        records.append('3.6.1')
                if self.IXSECT == 1:
                    records.append('3.7')
                    records.append('3.7.1')
                    if self.IPRFL == 0: 
                        records.append('3.8')
                        for i in range(self.LAYX):
                            records.append('3.8.1')
                            records.append('3.8.2')

        elif file == 'in_cld_rrtm':
            #iterate/read over records
            records = ['C1.1']
            if (self.INFLAG == 1) or (self.INFLAG == 2):
                for i in range(1 if type(self.LAY) != list else len(self.LAY)): #number of cloudy layers
                    records.append('C1.2')
            elif (self.INFLAG == 0) or (self.INFLAG == 10):
                for i in range(1 if type(self.LAY) != list else len(self.LAY)): #number of cloudy layers
                    records.append('C1.3')
                    if self.INFLAG == 10:
                        raise NotImplementedError('INFLAG=10 (spectrally-resolved COD) not yet supported!')
                        for i in range(15):
                            records.append('C1.3a')
        return records
    
    def copy(self):
        return copy.deepcopy(self)
    
    def write(self,fpaths=None, file='all'):
        '''
        Write instance of parserrtm.Input to text files needed to run RRTM_LW.
        
        behaviors:
        # non-str Sequence, file='all': input and in_cld
        # str or PathLike, file='all': input only
        # str or PathLike, file='input_rrtm': input only
        # str or PathLike, file='in_cld_rrtm': in_cld only
        # None, file='all': whatever of fpath_input_rrtm, fpath_in_cld_rrtm is defined
        # None, file='in_cld_rrtm': fpath_in_cld_rrtm must be defined
        # None, file='input_rrtm': fpath_input_rrtm must be defined
        
        -------------
        Arguments:
        self        : parserrtm.Input
        fpaths      : (str or list, optional) file write destinations. If str, write only input_rrtm.
                        If tuple, should be (fpath_input_rrtm, fpath_in_cld_rrtm). If None (default),
                        uses self.fpath_input_rrtm and self.fpath_in_cld_rrtm if needed.
        file        : (str, optional) kind of file to write. Options are 'input_rrtm', 'in_cld_rrtm' or 'all' (default).
        -------------
        Returns:
        None
        -------------
        '''

        if type(fpaths) != list:
            fpaths = [ fpaths ]
        if fpaths == None:
            fpaths = [ ]
            fpaths.append(self.fpath_input_rrtm)
            if hasattr(self.fpath_in_cld_rrtm):
                fpaths.append(self.fpath_in_cld_rrtm)
            elif file == 'in_cld_rrtm':
                raise ValueError('Cannot write in_cld_rrtm, no filename specified.')
            else:
                print('no fpath_in_cld_rrtm attribute present and\
                no filename specified, cannot write in_cld_rrtm')
            print(f'writing files {fpaths}')
#         elif (file == 'in_cld_rrtm') and (len(fpaths) == 1) and (self.ICLD == 1):
#             raise ValueError(f'Cannot write file in_cld_rrtm, no filename specified.')
        else:
            fpaths = fpaths.copy() #popping will mess it up if not copied
        
        methods = [self.write_input_rrtm, self.write_in_cld_rrtm]
        if file == 'all':
            while fpaths:
                methods.pop(0)(fpaths.pop(0))
        elif file == 'input_rrtm':
            self.write_input_rrtm(fpaths.pop(0))
        elif file == 'in_cld_rrtm':
            self.write_in_cld_rrtm(fpaths.pop(0))
            
        return
        
    def write_input_rrtm(self,fpath):
        records = self.get_explicit_record_order('input_rrtm')
        rundupe = self.copy()
        with open(fpath,'w') as f:
            f.write('\n')
            f.write('\n')
            f.write('file auto-generated by parserrtm\n')
            for rec in records:
                line = rundupe.write_record(rec)
                f.write(line+'\n')
            f.write('%')
            
    def write_in_cld_rrtm(self,fpath):
        records = self.get_explicit_record_order('in_cld_rrtm')
        rundupe = self.copy()
        with open(fpath,'w') as f:
            for rec in records:
                line = rundupe.write_record(rec)
                f.write(line+'\n')
            f.write('%\n')
            f.write('file auto-generated by parserrtm')
        
        
    def write_record(self,rec):
        '''
        RRTM record writer. Parse a record line using Fortran formats.
        Destructively writes out lists (should be run on a copy of self).
        
        -------------
        Arguments:
        self        : instance of parserrtm.Input
        rec         : (str) record name to write out
        -------------
        Returns:
        line        : (str) line formatted to fields
        -------------
        '''
        #get params for reader by polling self
        fmt    = self.get_format(rec)
        names  = self.get_fields(rec)
        
        #get list of fields to write
        vals = [ ]
        for key in names:
            attr = getattr(self,key)
            if type(attr) == list:
                val = attr.pop(0)
            else:
                val = attr
            vals.append(val)
        
        #parse fields from file line
        writer = FortranRecordWriter(fmt)
        line   = writer.write(vals)
        
        return line
        
    def read_in_cld_rrtm(self, fpath):
        '''
        Read and interpret "IN_CLD_RRTM" text file into the current instance.
        
        "IN_CLD_RRTM" contains information about cloud layers in the model and
        is only used if ICLD (record 1.2) = 1 or 2. Note that an "INPUT_RRTM"
        file must already be read into self before reading "IN_CLD_RRTM",
        since the formatting of "IN_CLD_RRTM" depends on some fields from
        "INPUT_RRTM" (namely ISCAT and NUMANGS).
        
        Scan the content of a file and interpret each line according to 
        the format, sequence, and naming described in the documentation
        file "rrtm_instructions". Each field is read into an attribute
        of the current instance. Repeated fields (e.g. user-defined profiles) 
        are read into a list in order of occurrence.
        
        NOTE: 
            For INFLAG=10, the fields TAUCLD, SINGLE-SCATTERING ALBEDO, PMOM(0:NSTR)
            are a list of lists. What this means: each item in the outer list is a 
            cloudy layer, while each item in the inner list are the cloud properties 
            for the 16 spectral bands in ascending order. 

            The first band is specified as C1.3, while the next 15 bands are 
            specified as C1.3a, which has fewer fields, which makes the formatting a bit
            unusual. Since no examples in the source code use INFLAG=10, this is untested!

        -------------
        Arguments:
        self        : instance of rrtmparse Input class
        fpath       : path to "IN_CLD_RRTM" file
        -------------
        Returns:
        self        : instance with all fields stored as attributes
        -------------
        '''
        
        with open(fpath,'r') as f:
            #read lines into list
            lines = f.readlines()
            self.lines = lines
            
        #get start and end lines (start line is zero)
        start_i, end_i = Input.get_input_rrtm_file_bounds(self.lines,file='in_cld_rrtm')
        
        #set read position to starting line
        self.read_i = start_i
        
        #determine derived parameter NSTR (# of mom. of phase function needed)
        self.NSTR = 0
        if (self.ISCAT==1) or (self.ISCAT==2):
            if self.NUMANGS==0:
                self.NSTR=4
            elif self.NUMANGS==1:
                self.NSTR=8
            elif self.NUMANGS==2:
                self.NSTR=16
            else:
                raise ValueError(f"'{NUMANGS}' not a valid NUMANGS value, \
                must be 0, 1, or 2 when ISCAT > 0")
                
        #iterate/read over records
        self.read_record('C1.1')
        if (self.INFLAG == 1) or (self.INFLAG == 2):
            self.read_record('C1.2',mode='new')
            while self.read_i < end_i:
                self.read_record('C1.2',mode='append')
        elif (self.INFLAG == 0) or (self.INFLAG == 10):
            self.read_record('C1.3',mode='new')
            while self.read_i < end_i:
                self.read_record('C1.3',mode='append')
                if self.INFLAG == 10:
                    for i in range(15):
                        self.read_record('C1.3a',mode='append depth')
        
        #check that we read up to the expected end of records
        if self.read_i != end_i:
            warnings.warn(f'{fpath} read finished on line {self.read_i} instead of {end_i} -- some of input is unread!')
            
        del self.lines
        return self

    def read_input_rrtm(self, fpath):
        '''
        Read and interpret "INPUT_RRTM" text file into the current instance.
        
        "INPUT_RRTM" contains the overall model setup and specifies surface
        boundary conditions, temperature and pressure profiles, which gases
        to simulate, and their concentration at levels.
        
        Scan the content of a file and interpret each line according to 
        the format, sequence, and naming described in the documentation
        file "rrtm_instructions". Each field is read into an attribute
        of the current instance. Repeated fields (e.g. user-defined profiles) 
        are read into a list in order of occurrence.

        -------------
        Arguments:
        self        : instance of parserrtm.Input
        fpath       : path to "INPUT_RRTM" file
        -------------
        Returns:
        self        : instance with all fields stored as attributes
        -------------
        '''
        #1. get file record layout
        #2. get field lists
        #3. loop over lines and store
        
        with open(fpath,'r') as f:
            #read lines into list
            lines = f.readlines()
            self.lines = lines
            
        #get start and end lines
        start_i, end_i = Input.get_input_rrtm_file_bounds(self.lines)
        
        #set read position to starting line
        self.read_i = start_i
        
        #sequentially read records of file
        self.read_record('1.1')
        self.read_record('1.2')
        self.read_record('1.4')
        if self.IATM == 0:
            self.read_record('2.1')
            for i in range(self.NLAYRS):
                self.read_record('2.1.1',mode='new' if i==0 else 'append')
                self.read_record('2.1.2',mode='new' if i==0 else 'append')
                if self.NMOL > 7:
                    self.read_record('2.1.3',mode='new' if i==0 else 'append')
            if self.IXSECT == 1:
                self.read_record('2.2')
                self.read_record('2.2.1')
                self.read_record('2.2.2')
                for i in range(self.NLAYRS):
                    self.read_record('2.2.3',mode='new' if i==0 else 'append') #dummy
                    self.read_record('2.2.4',mode='new' if i==0 else 'append')
                    if self.IXMOLS > 7:
                        self.read_record('2.2.5',mode='new' if i==0 else 'append')
        elif self.IATM == 1:
            self.read_record('3.1')
            self.read_record('3.2')
            if self.IBMAX == 0:
                self.read_record('3.3A')
            else:
                self.read_greedy_record('3.3B') #GREEDY
            if self.MODEL == 0:
                self.read_record('3.4')
                for i in range(self.IMMAX):
                    self.read_record('3.5',mode='new' if i==0 else 'append')
                    self.read_record('3.6.1',mode='new' if i==0 else 'append')
            if self.IXSECT == 1:
                self.read_record('3.7')
                self.read_record('3.7.1')
                if self.IPRFL == 0: 
                    self.read_record('3.8')
                    for i in range(self.LAYX):
                        self.read_record('3.8.1',mode='new' if i==0 else 'append')
                        self.read_record('3.8.2',mode='new' if i==0 else 'append')
                        
        if self.read_i != end_i:
            warnings.warn(f'{fpath} read finished on line {self.read_i} instead of {end_i} -- some of input is unread!')
            
        del self.lines
        return self

    def get_input_rrtm_file_bounds(lines,file='input_rrtm'):
        '''
        Find start and end lines for "INPUT_RRTM"  or "IN_CLD_RRTM" file.
        
        -------------
        Arguments:
        lines (list): list of lines of file (from file.readlines())
        file   (str): type of input file ('input_rrtm' or 'in_cld_rrtm')
        -------------
        Returns:
        start_i, end_i (int): line positions of first and last lines of file
        -------------
        '''

        #find start ('$') and end ('%') positions
        starts = [i for i,s in enumerate(lines) if s[0]=='$']
        ends   = [i for i,s in enumerate(lines) if s[0]=='%']
        
        #in_cld_rrtm has no starting '$' character and begins on the first line
        if file == 'in_cld_rrtm':
            starts = [0]

        #check '$' and '%' only occur once and '$' comes before '%'
        if (len(starts)==len(ends)==1) and (starts<ends):
            start_i, end_i = starts[0], ends[0]
        else:
            raise IOError(f"{fpath}: start lines '{starts}' and end lines '{ends}' not valid. Start is a line beginning with '$',\
            end is a line beginning with '%', and input file must have exactly one start and end with the start occurring before the end.")

        return start_i, end_i
    
    def read_record(self,rec,mode='new'):
        '''
        RRTM record reader. Parse a line using Fortran formats.
        Read into self.
        
        -------------
        Arguments:
        self        : instance of RRTM_LW parser class
        rec         : which record next line of file is
        mode        : options ('new','append','append depth'): 
                            -- new: create/overwrite attribute with read value
                            -- append: append new value to end of what's already there
                            -- append depth: convert last element to list and append (create list of lists)
        -------------
        Returns:
        self        : instance with fields of record added as attributes
        -------------
        '''
        #get params for reader by polling self
        s      = self.lines[self.read_i]
        fmt    = self.get_format(rec)
        names  = self.get_fields(rec)
        
        #parse fields from file line
        reader = FortranRecordReader(fmt)
        fields = reader.read(s)
        
        #assign fields as attributes
        for key,val in zip(names,fields):
            if mode=='new':
                setattr(self,key,val)
            
            elif mode=='append':
                l = getattr(self,key)
                if type(l) != list:
                    l = [l]
                l.append(val)
                setattr(self,key,l)
                
            elif mode=='append depth':
                l  = getattr(self,key)
                l2 = l[-1]
                if type(l2) != list:
                    l2 = [l2]
                l2.append(val)
                l[-1] = l2
                setattr(self,key,l)
            
        #step forwards one line
        self.read_i += 1
        return
    
    def read_greedy_record(self,rec):
        '''
        RRTM record reader. Parse a line using Fortran formats.
        Read into self. Read lines until all fields of record are filled.
        Note this only works for lines with generic formats (e.g. '(8F10.3)').

        -------------
        Arguments:
        self        : instance of RRTM_LW parser class
        rec         : which record next line of file is
        -------------
        Returns:
        self        : instance with fields added as attributes
        -------------
        '''
        #get params for reader by polling self
        s      = self.lines[self.read_i]
        fmt    = self.get_format(rec)
        names  = self.get_fields(rec)
        
        #record desired number of fields
        inames = len(names)
        
        #make an empty record
        record = { }
        
        #read once
        #parse fields from file line
        reader = FortranRecordReader(fmt)
        fields = reader.read(s)
        for key,val in zip(names,fields):
            record[key] = val
        self.read_i += 1
                
        #if fields are still missing, keep reading
        while len(record.keys()) < inames:
            #remove keys from names
            names = list(filter(lambda var: var not in list(record.keys()),names))
            
            #read with remaining names
            #parse fields from file line
            fields = reader.read(self.lines[self.read_i])
            for key,val in zip(names,fields):
                record[key] = val
            self.read_i += 1
        
        #write back to self after finished
        for key,val in record.items():
            setattr(self,key,val)
        return
    
    def get_format(self,rec): 
        '''
        Get dict of Fortran format-strings for each record.

        It's a method since some record formats (xsec records 2.1.1-3 and 2.2.4-5) 
        depend on the values of other records (IFORM and IFRMX).
        '''
        
        #dictionary of all record formats. Dynamic formats are stored as methods.
        #changed all E formats to ES and two E formats to F to align with example input file encoding
        formats = {
            '1.1':    '(1A80)',
            '1.2':    '(49X, I1, 19X, I1, 12X, I1, I2, 2X, I3, 4X, I1)',
            '1.4':    '(F10.3,  1X, I1, 2X, I1, 16F5.3)', #changed from E to F
            '2.1':    '(1X,I1, I3, I5)',
            '2.1.1':  lambda self: f"({'F10.4' if self.IFORM==0 else 'ES15.7'}, F10.4, 23X, F8.3, F7.2,  7X, F8.3,   F7.2)",
            '2.1.2':  lambda self: f"({'8ES10.3' if self.IFORM==0 else '8ES15.7'})",
            '2.1.3':  lambda self: f"({'8ES10.3' if self.IFORM==0 else '8ES15.7'})",
            '2.2':    '(I5)',
            '2.2.1':  '(7A10,(/,8A10))',
            '2.2.2':  '(1X,I1)',
            '2.2.3':  '(A1)', #dummy record
            '2.2.4':  lambda self: f"({'7ES10.3' if self.IFRMX==0 else '7ES15.7'})",
            '2.2.5':  lambda self: f"({'8ES10.3' if self.IFRMX==0 else '8ES15.7'})",
            '3.1':    '(I5, 5X, I5, 5X, I5, I5, I5, 3X, I2, F10.3, 20X, F10.3)',
            '3.2':    '(F10.3,  F10.3)',
            '3.3A':   '(F10.3,  F10.3,  F10.3, F10.3, F10.3)',
            '3.3B':   '(8F10.3)',
            '3.4':    '(I5, 3A8)',
            '3.5':    '(F10.3, F10.3, F10.3, 5X, A1, A1, 3X, 28A1)', #changed from E to F
            '3.6.1':  '(8ES10.3)',
            '3.7':    '(I5, I5, I5)',
            '3.7.1':  '(7A10,(/,8A10))',
            '3.8':    '(I5, I5, A50)',
            '3.8.1':  '(F10.3, 5X, 35A1)',
            '3.8.2':  '(8ES10.3)',
            'C1.1':   '(3X, I2,  4X, I1,  4X, I1)',
            'C1.2':   '(A1, 1X, I3, ES10.3, ES10.3, ES10.3, ES10.3, ES10.3)', #changed from E10.5 to ES10.3
            'C1.3':   '(A1, 1X, I3, ES10.3, ES10.3, ES10.3, ES10.3, ES10.3)', #changed from E10.5 to ES10.3
            'C1.3A':  '(15X, E10.5, E10.5, 16E10.5)'
        }
        
        #get format
        fmt = formats[rec]
        
        #if format is a method, evaluate it
        if hasattr(fmt, '__call__'):
            fmt = fmt(self)
            
        #return format
        return fmt
                   
    def get_fields(self,rec):
        '''
        Get dict of lists of field names for each record.

        It's a method since the number and names of many records' fields 
        depend on a field stored in some previous record. If a value is a
        function, it will be evaluated with the fields currently read in
        as attributes.
        '''
        
        #dictionary of all record formats. Dynamic formats are stored as methods.
        records_fields = {
            '1.1':     ['CXID'],
            '1.2':     ['IATM',  'IXSECT', 'ISCAT',  'NUMANGS',   'IOUT',   'ICLD'],
            '1.4':     ['TBOUND',  'IEMIS', 'IREFLECT', *[f'SEMISS({IB})' for IB in range(1,16+1)]],
            '2.1':     ['IFORM', 'NLAYRS', 'NMOL'],
            '2.1.1':   ['PAVE',  'TAVE',    'PZ(L-1)',  'TZ(L-1)',   'PZ(L)',  'TZ(L)'],
            '2.1.2':   ['WKL(1,L)','WKL(2,L)','WKL(3,L)','WKL(4,L)','WKL(5,L)','WKL(6,L)','WKL(7,L)','WBROAD(L)'],
            '2.1.3':   lambda self: [f'WKL({M},L)' for M in range(self.NMOL-7)],
            '2.2':     ['IXMOLS'],
            '2.2.1':   lambda self: [f'XSNAME({I})' for I in range(1, self.IXMOLS+1)],
            '2.2.2':   ['IFRMX'],
            '2.2.3':   ['_'], #dummy record
            '2.2.4':   lambda self: [f'XAMNT({I})' for I in range(1, 8)],
            '3.1':     ['MODEL',   'IBMAX',  'NOPRNT',  'NMOL', 'IPUNCH',   'MUNITS',    'RE',      'CO2MX'],
            '3.2':     ['HBOUND','HTOA'],
            '3.3A':    ['AVTRAT', 'TDIFF1', 'TDIFF2', 'ALTD1', 'ALTD2'],
            '3.3B':    lambda self: [f"{'Z' if self.IBMAX>0 else 'P'}BND({I})" for I in range(1, abs(self.IBMAX)+1)],
            '3.4':     ['IMMAX','HMOD'],
            '3.5':     ['ZM', 'PM', 'TM', 'JCHARP', 'JCHART', *[f'JCHAR({K})'for K in range(1,28+1)]],
            '3.6.1':   lambda self: [f'VMOL({K})'for K in range(1,self.NMOL+1)],
            '3.7':     ['IXMOLS','IPRFL','IXSBIN'],
            '3.7.1':   lambda self: [f'XSNAME({I})' for I in range(1, self.IXMOLS+1)],
            '3.8':     ['LAYX','IZORP','XTITLE'],
            '3.8.1':   ['ZORP', *[f'JCHARX({K})'for K in range(1,28+1)]], #JCHAR(K) is already taken by record 3.5
            '3.8.2':   lambda self: [f'DENX({K})' for K in range(1, self.IXMOLS+1)],
            'C1.1':    ['INFLAG', 'ICEFLAG', 'LIQFLAG'],
            'C1.2':    ['TESTCHAR','LAY','CLDFRAC','CWP','FRACICE','EFFSIZEICE','EFFSIZELIQ'],
            'C1.3':    lambda self: ['TESTCHAR', 'LAY', 'CLDFRAC', 'TAUCLD', 
                                     'SINGLE-SCATTERING ALBEDO', *[f'PMOM({N})' for N in range(self.NSTR)]],
            'C1.3A':   lambda self: ['TAUCLD', 'SINGLE-SCATTERING ALBEDO', *[f'PMOM({N})' for N in range(self.NSTR)]]
        }
        
        #get fields
        fields = records_fields[rec]
        
        #if fields is a method, evaluate it
        if hasattr(fields, '__call__'):
            fields = fields(self)
            
        #return fields
        return fields

### RUNNER CLASS ###
class Runner:
    def __init__(self,n_workers=8,tmp_path='/private/tmp/lima',shell='/usr/local/bin/lima sh -c',
                 exec_path='~/linuxvm/rrtm_lw_pgf90/rrtm_v3.3_linux_pgf90',clean=True):
        #set attrs
        self.n_workers = n_workers
        self.clean     = clean
        self.tmp_path  = Path.expanduser(Path(tmp_path))
        self.exec_path = Path.expanduser(Path(exec_path))
        if shell:
            self.shell = shell
        else:
            self.shell = ''
        #pick unqiue identifier
        self.uid = '{:04d}'.format(np.random.randint(10000))
        #remove other worker directories
        if self.clean: 
            Runner.rmdirs(self.tmp_path,'any')
        else:
            Runner.rmdirs(self.tmp_path,self.uid)
        #make worker directories
        dirs = Runner.mkdirs(self.n_workers,self.tmp_path,self.uid)
        self.dirs = dirs
        #link executable into worker directories
        Runner.lndirs(self.dirs,self.exec_path)
        return

    def mkdirs(n_workers,tmp_dir,uid):
        '''create worker directories'''
        dirpaths = [tmp_dir/f'rrtm{uid}_worker{i:02d}' for i in range(n_workers)]
        _        = [Path.mkdir(p) for p in dirpaths]
        print(f'created {len(dirpaths)} worker directories at {tmp_dir}')
        return dirpaths

    def lndirs(dirpaths,exec_path):
        '''symlink executable into worker dirs'''
        for p in dirpaths:
            subprocess.run(['ln','-s',(exec_path).resolve(),'rrtm'],cwd=p,check=True)
        return

    def rmdirs(path,uid,rms=['OUTPUT_RRTM','INPUT_RRTM','IN_CLD_RRTM',
                             'OUT_CLD_RRTM','TAPE6','TAPE7','rrtm.log','rrtm']):
        '''remove unused rrtm worker directories'''

        #if uid is specified, match that 4-digit string.
        #if uid == 'any', match any 4-digit number
        if uid=='any':
            uid='\d{4}'

        #make a regex to match worker directory names
        #format is rrtmXXXX_workerYY: XXXX is uid and YY is worker number
        exp = re.compile(f'rrtm{uid}_worker\d+')

        #get all matching paths in path
        paths = filter(lambda p: exp.fullmatch(p.name),path.glob('*'))
        paths = list(paths)

        #remove directories
        for p in paths:
            #remove all accepted temporary files
            _ = [(p/name).unlink(missing_ok=True) for name in rms]
            #try removing directory
            p.rmdir()
        print(f'removed {len(paths)} worker directories at {path}')
        return

    def run(self,inputs,ignored_warnings = ['Warning: ieee_underflow is signaling',
                                            'Warning: ieee_inexact is signaling',
                                            'FORTRAN STOP']):
        '''run RRTM on a list of parserrtm.Inputs and return output'''
        outputs = [ ]
        logs = [ ]
        i=0
        print(f'starting {len(inputs)} jobs')
        while i<len(inputs):
            print(f'{len(inputs)-i} jobs remaining')
            
            #wipe worker directories
            print(f'\t wiping {len(self.dirs)} directories. Running:')
            for dir in self.dirs:
                p = subprocess.run(self.argproc('rm OUTPUT_RRTM INPUT_RRTM IN_CLD_RRTM OUT_CLD_RRTM TAPE6 TAPE7 rrtm.log'),
                                   cwd=dir,stderr=subprocess.DEVNULL,stdout=subprocess.DEVNULL)
            
            ps = [ ]
            logfilepaths = [dir/'rrtm.log' for dir in self.dirs]
            with contextlib.ExitStack() as stack:
                logfiles = [stack.enter_context(open(fname,'w')) for fname in logfilepaths]
                #submit jobs
                for j,dir in enumerate(self.dirs):
                    if i<len(inputs):
                        input = inputs[i]
                    else:
                        break
                    print(f'\t \t {input.name} in {dir.name}')
                    if input.ICLD:
                        input.write([dir/'INPUT_RRTM',dir/'IN_CLD_RRTM'])
                    else:
                        input.write(dir/'IN_CLD_RRTM')
                    p = subprocess.Popen(self.argproc('./rrtm'),shell=False,cwd=dir,stdout=logfiles[j],stderr=subprocess.STDOUT)
                    ps.append(p)
                    #print(f'\t \t {i}')
                    i+=1

                print('\t waiting...',end='')
                #wait for jobs to finish and check for successful execution
                for j,p in enumerate(ps):
                    returncode = p.wait()
                    if returncode != 0:
                        print(f'worker {self.dirs[j]} failed!')
                        raise subprocess.CalledProcessError(returncode,p.args)
                print('finished')
                #print(f'\t {i}')
        
            #collect outputs
            print(f'\t reading {len(ps)} outputs')
            for p,dir in zip(ps,self.dirs):
                #read outputs
                outputs.append(read_output(dir/'OUTPUT_RRTM'))
                #read logs
                with open(dir/'rrtm.log','r') as f:
                    log=f.read().splitlines() 
                    #check for successful completion
                    if log[-1] != 'FORTRAN STOP':
                        raise UserError(f"RRTM run in {dir}/rrtm.log did not terminate sucessfully! 'FORTRAN STOP' expected, got {log[-1]} instead")
                    for line in log:
                        if line not in ignored_warnings:
                            warnings.warn(f'{dir}/rrtm.log has non-accepted warning \'{line}\'')
                    logs.append(log)
        print(f'{len(inputs)-i} jobs remaining')
        print(f'finished {len(inputs)} jobs')
        return outputs, logs

    def argproc(self,cmd):
        '''format arguments to subprocess based on self.shell'''
        return splitfirst(prepend(self.shell,cmd))

def prepend(shell,cmd):
    '''prepend shell to cmd if shell is non-empty str'''
    return [shell,cmd] if len(shell)>0 else [cmd]

def splitfirst(l):
    '''split first list element along spaces'''
    return [*l[0].split(),*(l[1:] if len(l)>1 else [])]